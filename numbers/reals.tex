\begin{frame}{some real numbers}
\begin{itemize}
\item $\frac{1}{3}$
\item $-\frac{100}{7}$
\item $\pi$
\item $0.1$
\item $\sqrt{2}$
\item \ldots
\vspace{.5cm}
\item want to represent these:
    \begin{itemize}
    \item accurately? compactly? efficiently?
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{fixed point}
\begin{eqnarray*}
\frac{1}{3} &=& 0.101010101\ldots_\text{TWO}  \\\
            &\approx& +0000.1010_\text{TWO} \text{--- represent as {\tt 00000 1010}} \\
\frac{100}{7} &=& 1110.001001001\ldots_\text{TWO}  \\
            &\approx& -1110.0010_\text{TWO} \text{--- represent as {\tt 01110 0010}} \\
\end{eqnarray*}
\begin{itemize}
\item<2-> $x \approx y/2^K$ --- $y$ is a fixed-sized integer
\begin{itemize}
    \item this case: $y/2^4$ and $y$ is 9 bits.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{why fixed-point?}
\begin{itemize}
\item $x \approx y/2^K$ ($y$ fixed-sized integer)
\item math similar to integer math:
    \begin{itemize}
    \item addition/subtraction --- same
    \item multiplication --- same except divide by $2^{2K}$ at the end
    \item division --- same
    \end{itemize}
\item easy to understand what values are represented well
\end{itemize}
\end{frame}

\begin{frame}{why not fixed-point?}
\begin{itemize}
\item pretty small range of numbers for space used
\item hard to choose a $2^K$ that works for lots of applications
\end{itemize}
\end{frame}

\begin{frame}{recall (?): scientific notation}
\begin{eqnarray*}
+\frac{1}{3} &=& +0.33333333\ldots \\
            &\approx& \myemph<3>{+}\myemph<4>{3.33}\cdot \myemph<6>{10}^{\myemph<5>{-1}} \\
-\frac{100}{7} &=& -14.285714\ldots \\
            &\approx& \myemph<3>{-}\myemph<4>{1.42}\cdot \myemph<6>{10}^{\myemph<5>{+1}} \\
\end{eqnarray*}
\begin{itemize}
\item<2-> $\myemph<3>{\pm}\text{\myemph<4>{mantissa}} \cdot \text{\myemph<6>{base}}^\text{\myemph<5>{exponent}}$
\end{itemize}
\end{frame}

\begin{frame}{base-2 scientific notation}
\begin{eqnarray*}
\frac{1}{3} &=& 0.101010101\ldots_\text{TWO}  \\\
            &\approx& 0.1010101010_\text{TWO} =  +1.0101010101_\text{TWO} \cdot 2^-1\\
\frac{100}{7} &=& 1110.001001001\ldots_\text{TWO}  \\\
            &\approx& -1110.0010010_\text{TWO} = -1.1100010010_\text{TWO} \cdot 2^3\\
\end{eqnarray*}
\end{frame}

\begin{frame}{IEEE half-precision floating point}
\begin{tikzpicture}
\tikzset{
    >=Latex,
    labelLine/.style={draw,thick,dotted},
    myLabel/.style={align=center,font=\small},
    pm/.style={blue!70!black},
    mant/.style={green!60!black},
    expt/.style={orange!80!black},
}
\begin{scope}[every node/.style={inner sep=0mm}]
\node[pm] (pm) {-};
\node[anchor=base west] (onePt) at (pm.base east) {$1.$};
\node[anchor=base west,mant] (mant) at (onePt.base east) {$1100010010_\text{TWO}$};
\node[anchor=base west] (cdot) at (mant.base east) {\cdot};
\node[anchor=base west] (expt) at (cdot.base east) {$2^{\color{orange!80!black}3}$};
\end{scope}
\begin{visibleenv}<2->
\node[pm,below left=1cm of pm,myLabel] (signLabel) {sign (1 bit) };
\node[pm,below=0cm of signLabel,align=left] {
    $0$ for $+$ \\
    $1$ for $-$
};
\draw[pm,labelLine] (pm) -- (signLabel);
\node[mant,right=1.5cm of signLabel,myLabel] (mantLabel) {mantissa ($10$ bits)};
\draw[mant,labelLine] (mant) -- (mantLabel);
\node[mant,below=0cm of mantLabel,align=left] {
    don't store leading ``$1.$'' \\
    (because always present)
};
\node[right=1.5cm of mantLabel,myLabel,expt] (exptLabel) {exponent ($5$ bits)};
\draw[expt,labelLine] (expt) -- (exptLabel);
\node[expt,below=0cm of exptLabel,align=left] {
    store ``$3+15$'' \\
    $15$ is `bias'
};
\end{visibleenv}
\begin{visibleenv}<3->
    \node[below=2cm of mantLabel] (value) {
    \tt {\color{blue!70!black}1} {\color{orange!80!black}10010} {\color{green!60!black}1100010010}
};
\end{visibleenv}
\begin{visibleenv}<4->
\node[below=1cm of value,align=left] {
    on typical little endian system: \\
    byte 0: {\tt \color{green!60!black}00010010} \\
    byte 1: {\tt {\color{blue!70!black}1}{\color{orange!80!black}10010}\color{green!60!black}11}
};
\end{visibleenv}
\end{tikzpicture}
\end{frame}

\begin{frame}{IEEE half precision float}
\begin{itemize}
\item 1 sign bit ($1$ for negative)
\item 5 expontent bits
    \begin{itemize}
    \item bias of 15 --- if bits as unsigned are $e$, exponent is $E=e-127$
    \end{itemize}
\item 10 mantissa bits
    \begin{itemize}
    \item leading ``1.'' not stored
    \end{itemize}
\vspace{.5cm}
\item $\text{value} = (1-2\cdot \text{sign}) \cdot (1.\text{mantissa}_\text{TWO}) \cdot 2^{\text{exponent}-15}$
\end{itemize}
\end{frame}

\begin{frame}{other IEEE precisions}
\begin{tabular}{l|lll}
~ & half & single & double \\ \hline
C++*/Java type& --- & \texttt{float} & \texttt{double} \\
sign bits & 1 & 1 & 1 \\
exponent bits & 5 & 8 & 11 \\
    exponent bias & 15 {\small ($2^5-1$)} & 127 {\small ($2^7-1$)} & 1023 {\small ($2^{10}-1$)}\\
mantissa bits & 10 & 23 & 52 \\
total bits & 16 & 32 & 64 \\
\end{tabular}
    {\scriptsize (* = typical C++ type; might vary in some implementations)}
\end{frame}

% FIXME: single precision examples

\begin{frame}{\texttt{float} example: manually}
\begin{tikzpicture}
\tikzset{
    >=Latex,
    labelLine/.style={draw,thick,dotted},
    myLabel/.style={align=center,font=\small},
    pm/.style={blue!70!black},
    mant/.style={green!60!black},
    expt/.style={orange!80!black},
}
\node (calc) at (6, 0) { 
    $25.25 = \frac{101}{4} = 11001.01_{\text{TWO}} = $
};
\begin{scope}[every node/.style={inner sep=0mm}]
\node[pm] (pm) at ([yshift=-1cm,xshift=-4cm]calc) {+};
\node[anchor=base west] (onePt) at (pm.base east) {$1.$};
\node[anchor=base west,mant] (mant) at (onePt.base east) {$1001\,0100\,0000\,0000\,0000\,000_\text{TWO}$};
\node[anchor=base west] (cdot) at (mant.base east) {\cdot};
\node[anchor=base west] (expt) at (cdot.base east) {$2^{\color{orange!80!black}4}$};
\end{scope}
\begin{visibleenv}<2->
\node[pm,below left=1cm and -.5cm of pm,myLabel] (signLabel) {sign (1 bit) };
\node[pm,below=0cm of signLabel,align=left,font=\small] {
    $0$ for $+$
};
\draw[pm,labelLine] (pm) -- (signLabel);
\node[mant,right=1cm of signLabel,myLabel] (mantLabel) {mantissa ($23$ bits)};
\draw[mant,labelLine] (mant) -- (mantLabel);
\node[mant,below=0cm of mantLabel,align=left,font=\small] {
    (leading ``$1.$'' not stored)\\
};
\node[right=1.5cm of mantLabel,myLabel,expt] (exptLabel) {exponent ($5$ bits)};
\draw[expt,labelLine] (expt) -- (exptLabel);
\node[expt,below=0cm of exptLabel,align=left,font=\small] {
    store ``$4+127=$\\
    $1000\,0011_\text{TWO}$'' \\
    $127$ is bias for \texttt{float}
};
\end{visibleenv}
\begin{visibleenv}<3->
\node[below=2cm of mantLabel,font=\small\tt] (value) {
    {\color{blue!70!black}0} {\color{orange!80!black}1000$\,$0011} {\color{green!60!black}1001$\,$0100$\,$0000$\,$0000$\,$0000$\,$000}
};
\end{visibleenv}
\end{tikzpicture}
\end{frame}

\begin{frame}{diversion: 25.25 to binary}
\begin{eqnarray*}
    25.25 &=& 2^4 + (25.25-2^4) = 2^4 + 9.25 \\
          &=& 2^4 + 2^3 + (9.25-2^3) = 2^4 + 2^3 + 1.25 \\
          &~& (1.25 < 2^2) \\
          &~& (1.25 < 2^1) \\
          &=& 2^4 + 2^3 + (1.25-2^0) = 2^4 + 2^3 + 2^0 + 0.25 \\
          &~& (0.25 < 2^{-1}) \\
          &=& 2^4 + 2^3 + 2^0 + (0.25 - 2^{-2}) = 2^4 + 2^3 + 2^0 + 2^{-2} \\
          &=& 11001.01_\text{TWO}
\end{eqnarray*}
\end{frame}

\begin{frame}[fragile,label=floatUnion]{\texttt{float} example: from C++}
\lstset{
    language=C++,
    style=smaller
}
% FIXME: discussion about union
\begin{lstlisting}
#include <iostream>
using std::cout; using std::hex; using std::endl;
// union: all elements use the *same memory*
union floatOrInt {
    float f;
    unsigned int u;
};
int main() {
    union floatOrInt x;
    x.f = 25.25;
    cout << hex << x.u << endl;
// OUTPUT: 41ca0000
}
\end{lstlisting}
\begin{tikzpicture}
    \matrix[tight matrix noline,nodes={font=\tt,text width=1.5cm,align=center}] {
    4 \& 1 \& c \& a \& 0 \& 0 \& 0 \& 0 \\
    {\color{blue!70!black}0}{\color{orange!80!black}100} \& \color{orange!80!black}0001 \& \color{green!60!black}1100 \& \color{green!60!black}1010 \& \color{green!60!black}0000 \& \color{green!60!black} 0000 \& \color{green!60!black}0000 \& \color{green!60!black}0000 \\
};
\end{tikzpicture}
\end{frame}

% FIXME: use divide-by-10 in binary example

\begin{frame}{\texttt{float} example 2: manually}
\begin{tikzpicture}
\tikzset{
    >=Latex,
    labelLine/.style={draw,thick,dotted},
    myLabel/.style={align=center,font=\small},
    pm/.style={blue!70!black},
    mant/.style={green!60!black},
    expt/.style={orange!80!black},
}
\node[align=center] (calc) at (6, 0) { 
    $0.1_\text{TEN} = \frac{1}{16} + 0.0375 = \frac{1}{16} + \frac{1}{32} + 0.00625 = $ \\
    \strut$\ldots = 0.00011001100110011\ldots_\text{TWO} \myemph<4>{\approx}$ 
};
\begin{scope}[every node/.style={inner sep=0mm}]
\node[pm] (pm) at ([yshift=-1.5cm,xshift=-4cm]calc) {+};
\node[anchor=base west] (onePt) at (pm.base east) {$1.$};
    \node[anchor=base west,mant] (mant) at (onePt.base east) {$1001\,1001\,1001\,1001\,1001\,10\mathbf{1}_\text{TWO}$};
\node[anchor=base west] (cdot) at (mant.base east) {\cdot};
\node[anchor=base west] (expt) at (cdot.base east) {$2^{\color{orange!80!black}-4}$};
\end{scope}
\begin{visibleenv}<2->
\node[pm,below left=1cm and -.5cm of pm,myLabel] (signLabel) {sign (1 bit) };
\node[pm,below=0cm of signLabel,align=left,font=\small] {
    $0$ for $+$
};
\draw[pm,labelLine] (pm) -- (signLabel);
\node[mant,right=1cm of signLabel,myLabel] (mantLabel) {mantissa ($23$ bits)};
\draw[mant,labelLine] (mant) -- (mantLabel);
\node[mant,below=0cm of mantLabel,align=left,font=\small] {
    last $\mathbf{1}$ from \myemph<4>{rounding}
};
\node[right=1.5cm of mantLabel,myLabel,expt] (exptLabel) {exponent ($5$ bits)};
\draw[expt,labelLine] (expt) -- (exptLabel);
\node[expt,below=0cm of exptLabel,align=left,font=\small] {
    store ``$-4+127=$\\
    $0111\,1011_\text{TWO}$''
};
\end{visibleenv}
\begin{visibleenv}<3->
\node[below=1cm of mantLabel,font=\small\tt] (value) {
    {\color{blue!70!black}0} {\color{orange!80!black}0111$\,$1011} {\color{green!60!black}1001$\,$1001$\,$1001$\,$1001$\,$1001$\,$001}
};
\end{visibleenv}
\begin{visibleenv}<4->
\node[below=0cm of value] {
    \myemph<4>{closest} \texttt{float} to 0.1
    between $0.1$ and $0.1000001$
};
\end{visibleenv}
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile,label=floatEx2In1]{\texttt{float} example 2: inaccurate (1)}
\lstset{
    language=C++,
    style=smaller
}
\begin{lstlisting}
#include <iostream>
using std::cout; using std::endl;

int main(void) {
    int count;
    float base = 0.1f;
    for (count = 0; base * count < 10000000; ++count) {}
    cout << count << endl;
    // OUTPUT: 99999996
    return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile,label=floatEx2In2]{\texttt{float} example 2: inaccurate (2)}
\lstset{
    language=C++,
    style=smaller
}
\begin{lstlisting}
#include <iostream>
using std::cout; using std::endl;

int main(void) {
    int count = 0;
    for (float f = 0; f < 2000.0; f += 0.1) {
        ++count;
    }
    cout << count << endl;
    // OUTPUT: 20004
    return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile,label=floatEx2In3]{\texttt{float} example 2: inaccurate (3)}
\lstset{
    language=C++,
    style=smaller
}
\begin{lstlisting}
#include <iostream>
using std::cout; using std::endl;
int main(void) {
    cout.precision(30);
    for (float f = 0; f < 2000.0; f += 0.1) {
        cout << f << endl;
    }
    return 0;
}
\end{lstlisting}
\hrule
\small\tt
0 \\
0.100000001490116119384765625 \\
0.20000000298023223876953125 \\
\ldots \\
2.2000000476837158203125 \\
2.2999999523162841796875 \\
\ldots
\end{frame}

% FIXME: 0.1 can't be represented
% FIXME: zero
% FIXME: infinity
% FIXME: denormal
% FIXME: converting to/from IEEE format
% FIXME: catastrophic cancellation
% FIXME: not associative
