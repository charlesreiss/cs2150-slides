\typeout{(body.tex)}

\begin{frame}
    \titlepage
\end{frame}

\section{history}

\input{x86History}

% FIXME: 4, 8, 16, 32, 64-bit words
    % AMD64
    % asm compatiblity

    % AMD/Intel/others

\section{preliminary note: asm syntax}

\input{asmSyntax}

\section{x86 registers}

\input{x86Registers}

% FIXME: possible mov EAX, 1 versus mov AX, 1 note

\section{x86 fetch/execute cycle}

\input{x86FetchExecute}

\section{assembly syntax}

\subsection{directives for constants}
% FIXME: + section .data / section .text
% FIXME: + labels

\input{asmConstants}

\subsection{mov}

\input{mov}

\subsection{addressing modes}

\input{specifyPointer}

\subsection{mov example}

\input{movExample}

% FIXME: missing "is mov valid quiz?"

\section{selected instructions}

\subsection{(more) data movement}

\subsubsection{push/pop}

\input{pushPop}

\subsection{arithmetic instructions}

\subsubsection{add/sub}

\input{addSub}

\subsubsection{inc/dec}

\input{incDec}

\subsubsection{imul/idiv/mul/div}

\input{mulDiv}

\subsubsection{lea}

\input{lea}

% FIXME: lea examples

\subsection{logical instructions}

\subsubsection{and/or/xor}

\input{andOrXor}

\subsection{control flow}

\subsubsection{jmp}

\input{jmp}

\subsubsection{cmp+jxx}

\input{condJmp}

\subsubsection{call/ret}

\input{callRet}

\section{C to assembly example}

\input{cToAsmEx}

\section{calling convention}

\subsection{example call in C}

\input{callExample}

\subsection{calls and the stack}

\input{callsWithTheStack}
    % FIXME: stack grows down

\subsection{calling convention questions}

\input{callQuestions} % and caller versus callee
\subsection{caller rules}

\input{callerRules} % FIXME: stack diagram

    % FIXME: second example along with stack contents

\subsection{callee rules}

    % FIXME: example
%\input{calleeRulesPre}
\input{calleeRulesNaive1}
\input{calleeRulesNaive1Anim}
\input{calleeAllocRegs}
\input{calleeAllocRegsAnim}
\input{calleeRulesCompiler}
\input{calleeRulesNaive2}
\input{optVNot}
\input{calleeSampleBetter}
\input{calleeSampleGood}
\input{calleeRules}
\input{calleeSampleWeird}

     %FIXME animation

\section{activation records}

\input{activRecords}

\section{memory layout}

\input{programMemory}

\section{buffer overflows}

\input{bufferOver}

\section{on frame pointers}

\input{framePointer}
    % FIXME: example?

\section{x86 examples}

\subsection{note: godbolt.org}

\input{godboltOrg}

\subsection{nasm for clang output}

\input{nasmClangOut}

\subsection{absolute value}

\input{absValueC}

\input{absValueATT}

\subsubsection{diversion: AT\&T syntax and clang}

\input{attVIntel}

\input{absValueIntel}

\subsubsection{diversion: the rest of the asm file}
\input{absValueContext}

\subsubsection{diversion: extern "C"}

\input{absValueExternC}

\subsection{max}

\input{maxC}

\input{maxNaiveAsm}

\input{maxOptAsm}

\subsection{compare string}

\input{cmpStrC}

\input{cmpStrAsm}

\subsection{fib}

\input{fibC}

\input{fibAsm}

\section{varargs}

% FIXME: varargs
