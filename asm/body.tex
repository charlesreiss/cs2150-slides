\typeout{(body.tex)}

\begin{frame}
    \titlepage
\end{frame}

\section{history}

\input{x86History}

% FIXME: 4, 8, 16, 32, 64-bit words
    % AMD64
    % asm compatiblity

    % AMD/Intel/others

\section{preliminary note: asm syntax}

\input{asmSyntax}

\section{x86 registers}

\input{x86Registers}

% FIXME: possible mov EAX, 1 versus mov AX, 1 note

\section{x86 fetch/execute cycle}

\input{x86FetchExecute}

\section{assembly syntax}

\subsection{directives for constants}
% FIXME: + section .data / section .text
% FIXME: + labels

\input{asmConstants}

\subsection{mov}

\input{mov}
\subsection{mov example}

\input{movExample}

% FIXME: missing "is mov valid quiz?"

\section{selected instructions}

\subsection{(more) data movement}

\subsubsection{push/pop}

\input{pushPop}

\subsection{simple arithmetic instructions}

\subsubsection{add/sub}

\input{addSub}

\subsection{control flow}

\subsubsection{jmp}

\input{jmp}

\subsubsection{cmp+jxx}

\input{condJmp}

\section{C to assembly example}

\input{cToAsmEx}

\subsubsection{call/ret}

\input{callRet}

\section{calling convention preview}

\subsection{calls and the stack}

\input{callsWithTheStack}

\subsection{argument/ret val/etc. preview}

\input{callConvPreview}

\subsection{recursive call example}

\input{simpleRecurse}

\section{addressing modes}

\input{specifyPointer}

\section{less simple arithmetic/logical instructions}

\subsubsection{inc/dec}

\input{incDec}

\subsection{imul/idiv/mul/div}

\input{mulDiv}

\subsection{lea}

\input{lea}

\subsection{example call in C}

\input{callExample}

    % FIXME: stack grows down

\subsection{calling convention questions}

\input{callQuestions} % and caller versus callee

\subsection{caller rules}

\input{callerRules} % FIXME: stack diagram

    % FIXME: second example along with stack contents


\subsection{callee rules}

    % FIXME: example
%\input{calleeRulesPre}
\input{calleeRulesNaive1}
\input{calleeRulesNaive1Anim}
%\input{lastTime}
\input{calleeAllocRegs}
\input{calleeAllocRegsAnim}
\input{calleeRulesCompiler}
\input{calleeRulesNaive2}
\input{optVNot}
\input{calleeRulesBetter}
\input{calleeSampleGood}
\input{calleeRules}
\input{calleeSampleWeird}

     %FIXME animation

\section{activation records}
\input{activRecords}

\section{calling convention reference}

\input{callingConvMisc}

\subsection{logical instructions}

\subsubsection{and/or/xor}

\input{andOrXor}

\subsection{other flag setting instructions}

\input{otherFlag}

\section{memory layout}

\input{programMemory}


\section{x86 examples}

\subsection{note: godbolt.org}

\input{godboltOrg}

\subsection{things being optimized away}

\input{optAway}

\subsection{nasm for clang output}

\input{nasmClangOut}

\subsection{absolute value}

\input{absValueC}

\input{absValueATT}

\subsubsection{diversion: AT\&T syntax and clang}

\input{attVIntel}

\input{absValueIntel}

\subsubsection{without cmov}

\input{absValueNoCmov}

\subsubsection{diversion: the rest of the asm file}
\input{absValueContext}

\subsubsection{diversion: extern "C"}

\input{absValueExternC}


\section{on frame pointers}

\input{framePointer}
    % FIXME: example?

\subsection{max}

\input{maxC}

\input{maxNaiveAsm}

\input{maxOptAsm}

\subsection{compare string}

\input{cmpStrC}

\input{cmpStrAsm}

\subsection{fib}

\input{fibC}

\input{fibAsm}

\section{buffer overflows}

\input{bufferOver}

\section{varargs}

\input{onVarArgs}

% FIXME: missing varargs
