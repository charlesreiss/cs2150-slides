\begin{comment}
    \begin{frame}{last time}
    \begin{itemize}
    \item Huffman decoding --- construct + follow tree
    \item Huffman lab format, etc. reminders
        \begin{itemize}
        \item printable ASCII only --- 0x20 to 0x7e
        \end{itemize}
    \item graph definitions
        \begin{itemize}
        \item directed v undirected
        \item paths and cycles
        \item connected (undirected), weakly connected and strongly conneted (directed)
        \end{itemize}
    \item graph representations and their pros/cons
        \begin{itemize}
        \item adjacency matrix --- entry for every pair, no lists
        \item adjacency lists --- list for every vertex
        \end{itemize}
    \end{itemize}
\end{frame}
\end{comment}

\begin{comment}
\begin{frame}{last time}
    \begin{itemize}
    \item topological sort
        \begin{itemize}
        \item find node without incoming edges, remove, repeat
        \item implementation: track \textit{in-degrees}, enqueue when indegree becomes 0
        \item runtime: $\Theta(|V|+|E|)$ [$|E|$ total updates to in-degrees]
        \item queue: newly discovered nodes after known nodes
        \end{itemize}
    \item shortest path: breadth first search
        \begin{itemize}
        \item find distance 1 nodes, use those to find distance 2 nodes, etc.
        \item all parents at level $x$ then children
        \item queue: newly discovered nodes after known nodes
                \begin{itemize}
                \item versus pre-order: process immediately
                \end{itemize}
        \item extra tracking: don't `visit' node twice
        \end{itemize}
    \item representing shortest paths: shortest path tree
        \begin{itemize}
        \item only need edge from each node towards source
        \end{itemize}
    \end{itemize}
\end{frame}
\end{comment}

\begin{comment}
\begin{frame}{last time}
    \begin{itemize}
        \item breadth first search versus Dijkstra's
        \item find node at distance $X$ --- might find again at distance $Y<X$
        \item avoid processing nodes twice --- order of best found distance
            \begin{itemize}
            \item processing node at distance $X$, can't find path of distance $X-k$
            \end{itemize}
        \item priority queue to track pending nodes
            \begin{itemize}
            \item key = distance
            \item a use for \texttt{decreaseKey}
            \end{itemize}
        \item runtime $\Theta((|V|+|E|)\log |V|)$ with binary heaps
            \begin{itemize}
            \item priority queue operation for every vertex, then (almost) every edge
            \item $\Theta(|E|+|V|\log|V|)$ with better data structure
            \end{itemize}
        \vspace{.5cm}
        \item restriction: no negative weights
    \end{itemize}
\end{frame}
\end{comment}

\begin{comment}
\begin{frame}{last time}
    \begin{itemize}
    \item travelling salesperson problem
    \item i.e. min weight Hamiltonian cycle
        \begin{itemize}
        \item = visit all vertices once and return to start
        \end{itemize}
    \item the branch-and-bound idea
    \item lab preview:
        \begin{itemize}
        \item topological sort / naive TSP / report on TSP acceleration techs.
        \end{itemize}
    \item spanning tree --- connected graph with no cycles
        \begin{itemize}
        \item i.e. no extra edges
        \item application: transport network
        \end{itemize}
    \item minimum spanning tree: spanning tree with least weight
    \end{itemize}
\end{frame}
\end{comment}

\begin{frame}{last time}
    \begin{itemize}
    \item minimum spanning tree algorithms
    \item both \myemph{greedy} --- choose least cost candidate edge, never take back
    \item Prim's: start with one vertex, candidate edges: add new vertex to tree
    \item Prim's data structure: priority queue of vertices
        \begin{itemize}
        \item additionally track: `best' edge from used vertex to each unused
        \item add edge: check for better edges from new vertex
        \end{itemize}
    \item Prim's runtime: $\Theta((|E|+|V|)\log|V|)= \Theta(|E|\log|V|)$ (binary heap); $\Theta(|E|+|V|\log|V|)$ (Fib. heap)
    \item Kruskal's: don't track vertices, candidate edges: if don't create cycle
    \item Krusakl's data structure: union-find (continued today)
        \begin{itemize}
        \item use ``set-of(vertex)'' to detect if new edge creates a cycle
        \end{itemize}
    \item Kruskal's runtime: $\Theta(|E|\log|V|)$
    \end{itemize}
\end{frame}
