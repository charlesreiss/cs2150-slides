\typeout{(body.tex)}

\begin{frame}
    \titlepage
\end{frame}

\section{priority queues}

\subsection{motivation}

\input{prioMotivation}

\subsection{the ADT}

\input{prioADT}

\section{binary heaps}

\input{binaryHeapOverview}

\subsection{recall: complete/perfect binary tree}

\input{recallComplete}

\subsection{heap structure: almost complete tree}

\input{almostComplete}

\subsection{almost complete trees as arrays}

\input{almostCompleteAsArray}

\subsection{the heap property}

\input{heapProperty}

\subsection{heap code intro}

\input{heapCodeIntro}

\subsection{implementing insert}

\input{insertAlg}
    % FIXME: another example?

\subsubsection{percolate up}

\input{insertCode}

% FIXME: picture with code?

\subsubsection{runtime}

\input{insertRuntime}

\subsection{implementing deleteMin}

\input{deleteAlg}

\subsubsection{percolate down}

\subsubsection{runtime}

\subsection{misc. operations}

\subsection{diversion: heap sort}

\section{compression generally} 

\subsection{motivation}

\subsection{lossy compression}

\subsection{lossless compression}

\section{huffman coding}

\subsection{example prefix code}

\subsection{prefix code as tree}

\subsection{cost/optimality of codes}

\subsection{optimizing cost: high-level idea}

% FIXME: list of steps
    % find frequencies
    % create prefix code
    % write {prefix code, data encoded using prefix code}
    % saves space --- assuming data is big enough 

\subsection{finding frequencies}

% FIXME: determining frequency

\subsection{building huffman tree}

% FIXME: big idea: priority queue by frequency
                %  lowest frequency most important

% FIXME: manipulating trees

\subsection{example statistics}

\subsection{storing a prefix code}

\subsection{decoding}

\subsection{lab preview}

\section{heap implementation}

\subsection{class declaration}

\subsection{construction}

\subsection{findMin/deleteMin/insert}

\subsection{print}


% Probably unneeded

\subsection{ASCII}

\subsection{recall: full binary tree}


